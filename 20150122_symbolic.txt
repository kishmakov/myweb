=== Tags ===
design philosophy; syntax haskell; syntax cpp; ref paper hughes_1989;
=== Header ===
On Symbolic Finiteness
=== Summary ===
Thoughts on the relationship between finiteness of program symbolic
representation and finiteness of architectural entity set.
=== Body ===
Once we think about program, we could highlight two of its aspects:

* its textual representation
* its destination architecture

These aspects are related by compilation process. During compilation textual
representation turns into executable of destination architecture.

While programs textual representation can significantly vary from language
to language, next property is invariant: every program splits into finite
number of pieces which are operators and named entities such as variables and
functions. While operators number is bounded by language design what do we
mean by finiteness of named entities?

Often there is no theoretical bound for number of named entities. There is
only engineering bound caused by general finiteness of underling machine such
as operative memory and disk. But in practice human mind refuses to percept
effectively more then certain small number of named entities. This finiteness
of textual representation naturally transforms into finiteness of destination
architecture during compilation.

Once the destination architecture is hardware then its finiteness conditioned
by hardware design and manufacturing processes limitations. Those limitation
imply finiteness of instruction set, registers scheme and native data types.

If the destination scheme is not a hardware, we could iterate aforementioned
transformation and obtain current limitations in an inductive manner.
Moreover, if we track this hardware finiteness up to textual representation,
we would see that programming languages operator set finiteness is conditioned
by hardware finiteness.

<pre class='brush: cpp'>
// greatest common divisor
unsigned int gcd(unsigned int a, unsigned int b)
{
    return b == 0 ? a : gcd(b, a % b);
}
</pre>

Lets take a look at the paper [ref paper hughes_1989]

<pre class='brush: haskell'>
-- double list numbers
dbl2 :: [Int] -> [Int]
dbl2 = foldr (\ x xs -> [2 * x] ++ xs) []
</pre>