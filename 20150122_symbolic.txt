=== Tags ===
design philosophy; syntax haskell; syntax cpp; syntax mathjax;
=== Header ===
On Symbolic Finiteness
=== Summary ===
Thoughts on the relationship between finiteness of program symbolic
representation and finiteness of architectural entity set.
=== Body ===
## Finiteness as Trait

Once we think about program, we could highlight two of its aspects:

* its textual representation
* its destination architecture

These aspects are related by compilation process. During compilation textual
representation turns into executable of destination architecture.

While programs textual representation can significantly vary from language
to language, next property is invariant: every program splits into finite
number of pieces which are operators and named entities such as variables and
functions. While operators number is bounded by language design what do we
mean by finiteness of named entities?

Often there is no theoretical bound for number of named entities. There is
only engineering bound caused by general finiteness of underling machine such
as operative memory and disk. But in practice human mind refuses to percept
effectively more then certain small number of named entities. This finiteness
of textual representation naturally transforms into finiteness of destination
architecture during compilation.

Once the destination architecture is hardware then its finiteness conditioned
by hardware design and manufacturing processes limitations. Those limitation
imply finiteness of instruction set, registers scheme and native data types.

If the destination scheme is not a hardware, we could iterate aforementioned
transformation and obtain current limitations in an inductive manner.
Moreover, if we track this hardware finiteness up to textual representation,
we would see that programming languages operator set finiteness is conditioned
by hardware finiteness.

## Unified Setting

Our main intentions is to construct a unified setting which would provide a
language for natural description of finiteness as essential trait of
computational code. We would use next couple of examples for illustration needs:

<pre class='brush: cpp'>
// greatest common divisor
unsigned int gcd(unsigned int a, unsigned int b)
{
    return b == 0 ? a : gcd(b, a % b);
}
</pre>

<pre class='brush: haskell'>
-- double list numbers
dbl :: [Int] -> [Int]
dbl = foldr (\ x xs -> [2 * x] ++ xs) []
</pre>

Let us start to think about program execution in a bottom-up manner.
Underlying machine always operates sequentially. This discretization is
essentially determined by original sequential digital logic used for circuit
construction.

Underlying sequentiality could be lifted to the level of textual
representation with some caveats. Those caveats could be important once we
deal with parallel computing but for sequential computing they are of minor
interest.

In the first snippet there are five symbols which are initially undefined but
could become definite along computation:

1. input value `a`
2. input value `b`
3. `a % b`
4. `gcd(b, a % b)`
5. return value

In the second snippet there are 7 symbols which are initially undefined and
all of them would become definite along computation:

1. input value denoted as `i:is`
2. `i`, first element of `i:is`
3. `is`, tail of `i:is`
4. `dbl is`
5. `[2 * i]`
6. `[2 * i] ++ (dbl is)`
7. return value

In each of these two examples there are two possibility of assignation of
definite value to the return value holder. Because of this separation of
return value into separate symbol looks natural. It seems to be convenient
to distinguish input values and return values in all scheme to make them more
uniform.
